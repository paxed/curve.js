<!DOCTYPE html>
<html>
<head>
    <title>Neverball curve tool</title>
    <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<style>

h1.title { font-size: 1em; }

.wrapper { vertical-align:top; }

#container {
    width: 800px;
    height: 600px;
}

#otherstuff {
    border: 1px solid black;
    background-color: #d0d0d0;
    padding: 1em;
}

#mapc_map,
#mapc_params {
    font-family: monospace;
    white-space: pre;
}

</style>
</head>
<body>
<table id="wrapper">
<tr>
<td class="wrapper">
<h1 class="title">Neverball online curve tool</h1>
<div id="otherstuff">
 <div id="curve_inputs"></div>
 <a href="#" onclick="curve.random(); regen_scene();">randomize</a> |
 <a href="#" onclick="show_curve_map();">get .map</a> |
 <a href="#" onclick="change_camera(0);">reset&nbsp;cam</a>
 <hr>
 <div id="mapc_params"></div>
 <div id="mapc_map"></div>
</div>
</td>
<td class="wrapper"><div id="container"></div></td>
</table>
<script src="three.min.js"></script>
<script src="OrbitControls.js"></script>
<script src="utils.js"></script>

<script src="curve.js"></script>


<script>

var curve_vars = [
    { 'name': 'segments', 'varname': 'n', 'desc': 'Number of segments' },
    { 'name': 'angle', 'varname': 'a0', 'desc': 'Starting angle', 'joinline':1, 'separator': '-' },
    { 'varname': 'a1', 'desc': 'Ending angle' },
    { 'varname': 'thickness', 'desc': '' },
    { 'name': 'start radius', 'varname': 'r0', 'desc': 'Start inner radius', 'joinline':1, 'separator': '-'  },
    { 'varname': 'r1', 'desc': 'Start outer radius' },
    { 'name': 'end radius', 'varname': 'r2', 'desc': 'End inner radius', 'joinline':1, 'separator': '-'  },
    { 'varname': 'r3', 'desc': 'End outer radius' },
    { 'name': 'slope', 'varname': 'usesteps', 'desc': '', 'type':'checkbox', 'joinline':1, 'separator': ' ' },
    { 'varname': 'totalstep', 'desc': 'Number to slope up (positive) or down (negative)' },
    { 'varname': 'innerdrop', 'desc': 'Adjustment to the inner ring' },
    { 'varname': 'outerdrop', 'desc': 'Adjustment to the outer ring' },
    { 'varname': 'hill', 'desc': 'Adjustment to the middle of the curve' },
    { 'varname': 'ct', 'desc': '', 'type':'checkbox' },
];

var container;

var views, scene, renderer;
var control;
var clock;

var curve;

var meshes = new Array();
var light;

var windowWidth, windowHeight;
var allow_animation = 0;

var view = {
    background: new THREE.Color().setRGB( 0.5, 0.7, 0.7 ),
    eye: [ 0, 0, -800 ],
    up: [ 0, 1, 0 ],
    fov: 60
};

var textures = [
    new THREE.MeshBasicMaterial( { color: 0xff0000, wireframe: true, side:THREE.DoubleSide } ),
    new THREE.MeshBasicMaterial( { color: 0x00ff00, wireframe: true, side:THREE.DoubleSide } ),
    new THREE.MeshBasicMaterial( { color: 0x0000ff, wireframe: true, side:THREE.DoubleSide } ),
    new THREE.MeshBasicMaterial( { color: 0xffffff, wireframe: true, side:THREE.DoubleSide } ),
    new THREE.MeshBasicMaterial( { color: 0x000000, wireframe: true, side:THREE.DoubleSide } )
];

curve = new curve();
output_curve_inputs();
init();
//animate();
render();

function set_curve_var(v) {
    var e = $('curve_var_input_' + v);
    if (e.type == 'text') {
	curve.setvalue(v, e.value);
    } else if (e.type == 'checkbox') {
	curve.setvalue(v, e.checked ? 1 : 0);
    } else {
	alert("Unhandled set_curve_var elem type: " + e.type);
    }
    regen_scene();
}

function output_curve_inputs() {
    var str = '<table>';
    var joinline = 0;
    for (var i = 0; i < curve_vars.length; i++) {
	var c = curve_vars[i];
	var nam = c.name ? c.name : c.varname;
	if (!joinline) {
	    str += '<tr>';
	    str += '<td>' + nam + '</td>';
	    str += '<td>';
	}
	if (c.type == 'checkbox') {
	    str += '<input type="checkbox" onchange="set_curve_var(\''+c.varname+'\');" id="curve_var_input_'+c.varname+'"';
	    if (curve.getvalue(c.varname)) str += ' checked';
	    str += 'title="'+c.desc+'">';
	} else {
	    str += '<input type="text" onchange="set_curve_var(\''+c.varname+'\');" id="curve_var_input_'+c.varname+'" value="' + curve.getvalue(c.varname) + '" size="3" title="'+c.desc+'">';
	}
	joinline = c.joinline;
	if (c.separator) str += c.separator;
	if (!joinline) {
	    str += '</td>';
	    str += '</tr>';
	}
    }
    str += '</table>';
    $('curve_inputs').innerHTML += str;

    update_curve_inputs();
}

function update_curve_inputs() {
    for (var i = 0; i < curve_vars.length; i++) {
	var c = curve_vars[i];
	$('curve_var_input_'+c.varname).value = curve.getvalue(c.varname);
    }

    $('mapc_params').innerHTML = 'curve.exe '+curve.getparams();
}



function curve_render(c)
{
    for (var i = 0; i < c.data.length; i++) {
	var lump = c.data[i];
	for (var j = 0; j < lump.length; j++) {
	    var d = lump[j]; // sides of the lump
	    var geom = new THREE.Geometry();

	    geom.vertices.push( new THREE.Vector3( d.x0, d.y0, d.z0 ) );
	    geom.vertices.push( new THREE.Vector3( d.x1, d.y1, d.z1 ) );
	    geom.vertices.push( new THREE.Vector3( d.x2, d.y2, d.z2 ) );

	    geom.faces.push( new THREE.Face3( 0, 1, 2 ) );
	    geom.faces.push( new THREE.Face3( 1, 2, 0 ) );

	    var mesh = new THREE.Mesh( geom, textures[d.tex] );

	    meshes.push(mesh);

	    scene.add( mesh );
	}
    }
}

function change_camera(i)
{
    switch (i % 3) {
    default:
    case 0:
	camera.position.x = view.eye[0];
	camera.position.y = view.eye[1];
	camera.position.z = view.eye[2];
	break;
    case 1:
	camera.position.x = 800;
	camera.position.y = 0;
	camera.position.z = 0;
	break;
    case 2:
	camera.position.x = 0;
	camera.position.y = 800;
	camera.position.z = 0;
	break;
    }
    camera.lookAt( scene.position );
    render();
}

function show_curve_map()
{
    $('mapc_map').innerHTML='<textarea cols="50" rows="20">' + curve.getmap() + '</textarea>';
}

function dele() {
    while (meshes.length) {
	scene.remove( meshes.pop() );
    }
    curve.clear();
}

function init() {

    container = $( 'container' );

    camera = new THREE.PerspectiveCamera( view.fov, container.offsetWidth / container.offsetHeight, 1, 10000 );
    camera.position.x = view.eye[ 0 ];
    camera.position.y = view.eye[ 1 ];
    camera.position.z = view.eye[ 2 ];
    camera.up.x = view.up[ 0 ];
    camera.up.y = view.up[ 1 ];
    camera.up.z = view.up[ 2 ];
    view.camera = camera;

    scene = new THREE.Scene();

    camera.lookAt( scene.position );

/*
    light = new THREE.DirectionalLight( 0xffffff );
    light.position.set( 0, 0, 1 );
    scene.add( light );
*/
/*
    radius = 200;
    geometry  = new THREE.IcosahedronGeometry( radius, 1 );
    var materials = [
        new THREE.MeshLambertMaterial( { color: 0xffffff, shading: THREE.FlatShading, vertexColors: THREE.VertexColors } ),
        new THREE.MeshBasicMaterial( { color: 0x000000, shading: THREE.FlatShading, wireframe: true, transparent: true } )

    ];

    group1 = THREE.SceneUtils.createMultiMaterialObject( geometry, materials );
    group1.position.x = 0;
    group1.rotation.x = 0;
    scene.add( group1 );
*/



    curve.generate();
    curve_render(curve);


    renderer = new THREE.CanvasRenderer( { antialias: false } );
    renderer.setSize( container.offsetWidth, container.offsetHeight );

    container.appendChild( renderer.domElement );

    control = new THREE.OrbitControls(camera, renderer.domElement);

    renderer.domElement.onmousedown = mouse_rotation_enable;
    renderer.domElement.onmouseup = mouse_rotation_disable;

    clock = new THREE.Clock();

}

function mouse_rotation_enable(e)
{
    allow_animation = 1;
    animate();
}
function mouse_rotation_disable(e)
{
    allow_animation = 0;
}

function regen_scene()
{
    dele();
    //container.width = container.width;
    curve.generate();
    curve_render(curve);
    update_curve_inputs();
    render();
}

function updateSize() {
    if ( windowWidth != container.offsetWidth || windowHeight != container.offsetHeight ) {
        windowWidth  = container.offsetWidth;
        windowHeight = container.offsetHeight;
        renderer.setSize ( windowWidth, windowHeight );
    }
}


function animate() {
    var dt = clock.getDelta();
    control.update(dt);
    render();
    if (allow_animation) requestAnimationFrame( animate );
}


function render() {
    updateSize();

    camera = view.camera;

    renderer.setClearColor( view.background, 1 );

    camera.aspect = windowWidth / windowHeight;
    camera.updateProjectionMatrix();

    renderer.render( scene, camera );
}

</script>


</body>
</html>
